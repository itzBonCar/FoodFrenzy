#########################################################################################################

######### Imp git commands 
$ git remote add origin <repo-url>


$ git init
$ git clone <url>
$ git config --global user.email "92singh.yuvraj@gmail.com"
$ git status
$ git add .
$ git commit -m "message"
$ git push origin main
$ git pull origin main

$ git branch
$ git branch <new-branch-name>
$ git checkout <branch-name>
$ git checkout -b <new-branch-name>
$ git merge <branch-to-merge>

--> To change branch name from master to main
  1. rename your local branch
  $ git branch -m master main

  2. change the tracked branch
  $ git fetch -p origin
  $ git branch -u origin/master main

  3. change the main local branch
  $ git remote set-head origin -a

  4. optionally, remove the master branch, local and remotely:
  $ git branch -D master
  $ git push origin :master

#### Imp docker commands

$ docker login
$ docker tag <image-name>:latest itzboncar/<image-name>:latest
$ docker push itzboncar/<image-name>:latest
$ docker pull itzboncar/<image-name>:latest
$ docker build -t <image-name>:latest .
$ docker build -f Dockerfile.mysql -t <image-name>:latest .
$ docker run --name foodfrenzycontainer8 -d -p 9090:8080 -e SPRING_DATASOURCE_URL=jdbc:mysql://host.docker.internal:3306/food_frenzy_db -e SPRING_DATASOURCE_USERNAME=root -e SPRING_DATASOURCE_PASSWORD=carbon123 foodfrenzyimage:v01
$ docker ps 
$ docker ps -a 
$ docker images

$ docker exec -it <container-name> mysql -u root -p
>SHOW DATABASES;
USE food_frenzy_db;
SHOW TABLES;
SELECT * FROM admin;

$ docker logs <container-name>
$ docker logs -f <container-name>

#########################################################################################################

QUICK Git Commands:
git init
git remote add origin <url>
git configure --global user.email "92singh.yuvraj@gmail.com"
git clone <url>
git checkout master
git branch -m master main
git push -u origin main
IMP: Go to github and change default branch to 'main'. Only then follow next steps
git push origin -d master
git branch --unset-upstream
git branch -u origin/main
git branch -a
git status -sb
IMP: Now other devs should run
  git fetch origin
  git branch -m master main
  git branch -u origin/main main

git checkout -b feature/login
git checkout main
NOW: Make changes to files then,
git status
git add .  # To unstage, git restore --staged .
git commit -m "changed notes"
FETCH CHANGES,
git fetch
INSPECT CHANGES,
git log HEAD..origin/main
git log --oneline --left-right --graph HEAD...origin/main
git log --oneline --graph --decorate
git diff HEAD..origin/main
git status -sb
git log --left-right --oneline origin/main...HEAD
After Fetch, (assuming we want to merge to origin/feature/login branch which is ahead from our local branch)
git checkout feature/login
git merge origin/feature/login OR git rebase origin/feature/login
CAN, pull(= fetch + merge) if you know you want to merge instantly
git checkout feature/login
git pull origin feature/login
FINALLY,
git push origin feature/login


Git Best Practises:
Before switching branches with uncommitted changes, it is best practice to either commit or stash your changes to avoid potential conflicts or data loss.
Consider using $ git switch <branch_name> for switching branches and $ git restore <file_path> for restoring files for a clearer workflow.
When checking out a commit directly (not a branch name), you enter a "detached HEAD" state. Any commits made in this state won't belong to a branch and can be lost unless you explicitly create a branch from them using git checkout -b <new_branch_name>

Alias Git commands:
$ git config --global alias.lg "log --oneline --graph --all"
$ git config --global --unset alias.lg
$ git config --global --get-regexp '^alias\.'
$ git config --global --get-regexp '^.*$'



Git Stash:
$ git stash         # doesn't include new files not staged inside working copy for that use -u
$ git stash -u
$ git stash push -m "WIP: feature login"   # stash with a message
$ git stash pop     # clears stash and pops out the changes to working copy
$ git stash apply   # keeps changes in stash while also applying to working copy
$ git stash apply stash@{1}
$ git stash drop stash@{0}
$ git stash clear   # clear whole stash
$ git stash list
$ git stash branch <branchname> # create branch from stash

Git Branch:
$ git switch <branch-name>
$ git switch -c <branch-name>
$ git switch --detach <commit-hash>

$ git checkout -b new-feature   # create new branch, switch to it
$ git checkout <commit_hash_or_tag_name>    # checkout a specific commit, takes you to Detached mode, moves head to tht commit

$ git checkout master       # Change name of newly created master branch to main
$ git branch -m main        # this changes the local branch master to main and points to it
$ git branch -a                 # list all local and remote branches
$ git branch -d new-feature     # delete branch new-feature from local
$ git branch -D new-feature     # force delete branch new-feature from local
$ git push origin -d new-feature       # delete branch from remote
$ git push -u origin main        # -u means set-upstream which links local main to remote main

Check git remote:
$ git remote -v
$ git remote show origin

Using Git log:
$ git log -n 5  # Show only the last 5 commits
$ git log # q to quit, spacebar
$ git log --stat
$ git log -p
$ git log --grep="bug fix"
$ git log main..feature-branch # Shows all commits that are present in the second commit's history but not in the first commit's history
$ git log --oneline --graph --decorate
$ git log --oneline --graph --since="1 week ago" --author="yourname"
$ git log --oneline --graph --decorate --all --pretty=format:"%h %an %s"
$ git log --oneline --graph --decorate --all --author itzBonCar

Unstage Git files:
$ git add .
$ git --restore staged .

Git PULL:
$ git pull = git fetch + git merge
$ git fetch safe as it doesn't merge instantly

Git Merge:


CHECK IF REBASE NEEDED:
    git status
    git log --oneline --graph --decorate --all
    git log origin/main..HEAD
        # Output shown: Rebase might be needed
        # No Output: No rebase needed
    git log HEAD..origin/main
        # Output shown: Rebase might be needed
        # No Output: No rebase needed
    git log --left-right --oneline origin/main...HEAD
        > → commits only on your branch
        < → commits only on main

REBASING:
    Remote feature/login: A-B-C
    Remote main: A-B-C
When working alone on a feature branch, you make commit D, 
    Local feature/login: A-B-C-D, 

But, main moves forward 
    Remote main: A-B-C-X
No problem pushing 
    $ git push origin feature/login # works fine
Now, 
    Remote feature/login: A-B-C-D
    Remote main: A-B-C-X

Problem comes when merging to main, history won't match since main moved forward
Now, since feature/login is your branch alone(not shared), you can rebase, then merge feature/login to main in remote repo.
    $ git fetch origin
    Local:
        origin/main: A-B-C-X
        feature/login: A-B-C-D
        after rebase: 
        feature/login: A-B-C-X-D'
    $ git checkout feature/login
    $ git rebase origin/main
    $ git push --force-with-lease origin feature/login # Safe, your branch only so you can force push

    OR
    $ git checkout feature/login    # git checkout main is DANGEROUS
    $ git pull --rebase 
    equivalent to  
    $ git fetch
    $ git rebase origin/current-branch

Then, Open PR/merge safely
    remote main: A-B-C-X-M
                        \/
                        D'

Option A:
    Open a PR:
        $ git push origin feature/login
        Now on github/gitlab, compare branch main and feature/login, Click Create Pull Request
        CI will be triggered and one of merge strategy will be used; Merge, Squash Merge, Rebase & merge(sometimes)
        remote main: A-B-C-X-M
                            \/
                            D'

Option B:
    Merge locally(small teams, solo):
        $ git checkout main
        $ git pull origin main
        $ git merge feature/login
        $ git push origin main

Error: Branch is out of date
    when main moves forward and feature/login not caught up

REMEMBER:
Feature branch:
- You rebase
- You resolve conflicts
    $ git add login.js
    $ git rebase --continue
    Repeat for each conflicted commit
- You force-with-lease push

Main branch:
- You merge
- You never rebase
- You never force-push
