Git Best Practises:
Before switching branches with uncommitted changes, it is best practice to either commit or stash your changes to avoid potential conflicts or data loss.
Consider using $ git switch <branch_name> for switching branches and $ git restore <file_path> for restoring files for a clearer workflow.
When checking out a commit directly (not a branch name), you enter a "detached HEAD" state. Any commits made in this state won't belong to a branch and can be lost unless you explicitly create a branch from them using git checkout -b <new_branch_name>

Alias Git commands:
$ git config --global alias.lg "log --oneline --graph --all"
$ git config --global --unset alias.lg
$ git config --global --get-regexp '^alias\.'
$ git config --global --get-regexp '^.*$'



Git Stash:
$ git stash         # doesn't include new files not staged inside working copy for that use -u
$ git stash -u
$ git stash push -m "WIP: feature login"   # stash with a message
$ git stash pop     # clears stash and pops out the changes to working copy
$ git stash apply   # keeps changes in stash while also applying to working copy
$ git stash apply stash@{1}
$ git stash drop stash@{0}
$ git stash clear   # clear whole stash
$ git stash list
$ git stash branch <branchname> # create branch from stash

Git Branch:
$ git switch <branch-name>
$ git switch -c <branch-name>
$ git switch --detach <commit-hash>

$ git checkout -b new-feature   # create new branch, switch to it
$ git checkout <commit_hash_or_tag_name>    # checkout a specific commit, takes you to Detached mode, moves head to tht commit
$ git branch -a                 # list all local and remote branches
$ git branch -d new-feature     # delete branch new-feature from local
$ git branch -D new-feature     # force delete branch new-feature from local
$ git push -d new-feature       # delete branch from remote

Check git remote:
$ git remote -v
$ git remote show origin

Using Git log:
$ git log -n 5  # Show only the last 5 commits
$ git log # q to quit, spacebar
$ git log --stat
$ git log -p
$ git log --grep="bug fix"
$ git log main..feature-branch # Shows all commits that are present in the second commit's history but not in the first commit's history
$ git log --oneline --graph --decorate
$ git log --oneline --graph --since="1 week ago" --author="yourname"
$ git log --oneline --graph --decorate --all --pretty=format:"%h %an %s"
$ git log --oneline --graph --decorate --all --author itzBonCar

Unstage Git files:
$ git add .
$ git --restore staged .

Git PULL:
$ git pull = git fetch + git merge
$ git fetch safe as it doesn't merge instantly

Git Merge:


CHECK IF REBASE NEEDED:
    git status
    git log --oneline --graph --decorate --all
    git log origin/main..HEAD
        # Output shown: Rebase might be needed
        # No Output: No rebase needed
    git log HEAD..origin/main
        # Output shown: Rebase might be needed
        # No Output: No rebase needed
    git log --left-right --oneline origin/main...HEAD
        > → commits only on your branch
        < → commits only on main

REBASING:
    Remote feature/login: A-B-C
    Remote main: A-B-C
When working alone on a feature branch, you make commit D, 
    Local feature/login: A-B-C-D, 

But, main moves forward 
    Remote main: A-B-C-X
No problem pushing 
    $ git push origin feature/login # works fine
Now, 
    Remote feature/login: A-B-C-D
    Remote main: A-B-C-X

Problem comes when merging to main, history won't match since main moved forward
Now, since feature/login is your branch alone(not shared), you can rebase, then merge feature/login to main in remote repo.
    $ git fetch origin
    Local:
        origin/main: A-B-C-X
        feature/login: A-B-C-D
        after rebase: 
        feature/login: A-B-C-X-D'
    $ git checkout feature/login
    $ git rebase origin/main
    $ git push --force-with-lease origin feature/login # Safe, your branch only so you can force push

    OR
    $ git checkout feature/login    # git checkout main is DANGEROUS
    $ git pull --rebase 
    equivalent to  
    $ git fetch
    $ git rebase origin/current-branch

Then, Open PR/merge safely
    remote main: A-B-C-X-M
                        \/
                        D'

Option A:
    Open a PR:
        $ git push origin feature/login
        Now on github/gitlab, compare branch main and feature/login, Click Create Pull Request
        CI will be triggered and one of merge strategy will be used; Merge, Squash Merge, Rebase & merge(sometimes)
        remote main: A-B-C-X-M
                            \/
                            D'

Option B:
    Merge locally(small teams, solo):
        $ git checkout main
        $ git pull origin main
        $ git merge feature/login
        $ git push origin main

Error: Branch is out of date
    when main moves forward and feature/login not caught up

REMEMBER:
Feature branch:
- You rebase
- You resolve conflicts
    $ git add login.js
    $ git rebase --continue
    Repeat for each conflicted commit
- You force-with-lease push

Main branch:
- You merge
- You never rebase
- You never force-push
